<!DOCTYPE html>
<html>
<head>
    <title>Family Tree Generator</title>
    <style>
        textarea { width: 800px; height: 300px; }
        pre { white-space: pre-wrap; background: #f0f0f0; padding: 10px; }
    </style>
</head>
<body>
    <textarea id="input" placeholder="Enter family data here..."></textarea><br>
    <button onclick="generateTree()">Generate Tree</button>
    <button onclick="clearAll()">Clear</button>
    <pre id="output"></pre>

    <script>
        function clearAll() {
            document.getElementById('input').value = '';
            document.getElementById('output').textContent = '';
        }

        function generateTree() {
            const input = document.getElementById('input').value.trim();
            const people = new Map();
            const spouseRelations = new Set();

            // Parse input
            input.split('\n').forEach(line => {
                line = line.trim();
                if (!line) return;

                if (line.includes('+')) {
                    const [left, right] = line.split('+').map(s => s.trim());
                    processSpouses(people, spouseRelations, left, right);
                } else {
                    processChild(people, line);
                }
            });

            // Post-process to add children to all spouses
            people.forEach(person => {
                person.children.forEach(child => {
                    person.spouses.forEach(spouse => {
                        const spouseNode = people.get(spouse);
                        if (spouseNode && !spouseNode.children.includes(child)) {
                            spouseNode.children.push(child);
                        }
                    });
                });
            });

            // Build family lines
            const roots = getFamilyRoots(people);
            const output = [];
            
            roots.forEach(surname => {
                const tree = buildSurnameTree(people, surname);
                if (tree.length > 0) {
                    output.push(`Family Tree: ${surname}\n${tree.join('\n')}`);
                }
            });

            document.getElementById('output').textContent = output.join('\n\n');
        }

        function processSpouses(people, spouseRelations, left, right) {
            addPersonWithAncestry(people, left);
            addPersonWithAncestry(people, right);
            
            const key = [left, right].sort().join('+');
            if (!spouseRelations.has(key)) {
                people.get(left).spouses.add(right);
                people.get(right).spouses.add(left);
                spouseRelations.add(key);
            }
        }

        function processChild(people, child) {
            addPersonWithAncestry(people, child);
            let parent = findExistingParent(people, child);
            if (parent) linkParentChild(people, parent, child);
        }

        function addPersonWithAncestry(people, name) {
            if (!people.has(name)) {
                people.set(name, createPerson(name));
                buildAncestryChain(people, name);
            }
        }

        function buildAncestryChain(people, name) {
            let current = name;
            while (true) {
                const parentName = extractParentName(current);
                if (!parentName) break;
                if (!people.has(parentName)) people.set(parentName, createPerson(parentName));
                linkParentChild(people, parentName, current);
                current = parentName;
            }
        }

        function createPerson(name) {
            return {
                name: name,
                parent: null,
                spouses: new Set(),
                children: [],
                processed: false
            };
        }

        function linkParentChild(people, parent, child) {
            if (!people.get(parent).children.includes(child)) {
                people.get(parent).children.push(child);
            }
            people.get(child).parent = parent;
        }

        function extractParentName(name) {
            return name.split(' ').slice(1).join(' ') || null;
        }

        function findExistingParent(people, child) {
            let current = child;
            while (current) {
                const parent = people.get(current)?.parent;
                if (parent && people.has(parent)) return parent;
                current = parent;
            }
            return null;
        }

        function getFamilyRoots(people) {
            const surnames = new Set();
            for (const [name, person] of people) {
                if (!person.parent) surnames.add(getSurname(name));
            }
            return Array.from(surnames);
        }

        function getSurname(name) {
            return name.split(' ').pop();
        }

        function buildSurnameTree(people, surname) {
            const roots = Array.from(people.values())
                .filter(p => !p.parent && getSurname(p.name) === surname)
                .sort((a, b) => a.name.localeCompare(b.name));

            const output = [];
            const visited = new Set();

            roots.forEach(root => {
                const treeLines = [];
                buildTreeLines(root.name, 0, [], true, treeLines, visited, people, surname);
                output.push(...treeLines);
            });

            return output;
        }

        function buildTreeLines(name, depth, prefixes, isLast, output, visited, people, surname) {
            if (visited.has(name)) return;
            visited.add(name);

            const person = people.get(name);
            const spouses = Array.from(person.spouses)
                .sort((a, b) => a.localeCompare(b));

            // Build node line with spouses
            const nodeParts = [name];
            spouses.forEach(spouse => {
                if (getSurname(spouse) === surname || getSurname(name) === surname) {
                    nodeParts.push(spouse);
                }
            });

            const connector = depth === 0 ? '' : (isLast ? '└── ' : '├── ');
            const line = depth === 0 
                ? nodeParts.join(', ')
                : prefixes.slice(0, -1).join('') + connector + nodeParts.join(', ');

            output.push(line);

            // Process all children regardless of surname
            const children = [...person.children].sort((a, b) => a.localeCompare(b));

            children.forEach((child, index) => {
                const newPrefixes = [...prefixes];
                newPrefixes.push(index === children.length - 1 ? '    ' : '│   ');
                buildTreeLines(child, depth + 1, newPrefixes, index === children.length - 1, 
                             output, visited, people, surname);
            });
        }
    </script>
</body>
</html>