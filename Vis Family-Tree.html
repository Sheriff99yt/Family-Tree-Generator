<!DOCTYPE html>
<html>
    <head>
        <title>Family Tree Generator</title>
        <style>
        *, *:before, *:after { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Roboto', sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; background-color: #f8f9fa; color: #343a40; overflow: hidden; display: flex; transition: background-color 0.3s, color 0.3s; }
        body.dark-mode { background-color: #212529; color: #f8f9fa; }
        .sidebar { width: 320px; background-color: #fff; border-right: 1px solid #dee2e6; padding: 25px; display: flex; flex-direction: column; transition: transform 0.3s ease-in-out, border-color 0.3s, background-color 0.3s; z-index: 100; }
        .sidebar.dark-mode { background-color: #343a40; border-right-color: #495057; }
        .sidebar-header { margin-bottom: 20px; display: flex; align-items: center; justify-content: space-between; }
        .sidebar-header h2 { font-size: 1.5rem; font-weight: 500; margin: 0; }
        .sidebar.collapsed { transform: translateX(-300px); }
        .sidebar-toggle { transform: translateX(60px); background-color: transparent; color: #007bff; border: none; font-size: 1.5rem; transition: color 0.3s; }
        .sidebar-toggle:hover { transform: translateX(62px); color: #495057; }
        .sidebar-toggle.dark-mode { color: #adb5bd; }
        .sidebar-toggle.dark-mode:hover { color: #fff; }
        .search-container { margin-bottom: 20px; }
        .search-input { width: 100%; padding: 12px 15px; border: 1px solid #ced4da; border-radius: 0.25rem; font-size: 1rem; transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, color 0.3s; background-color: #fff; color: #495057; }
        .search-input:focus { border-color: #80bdff; box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); outline: 0; }
        .search-input.dark-mode { background-color: #495057; color: #fff; border-color: #5a6268; }
        .search-results { position: absolute; width: calc(320px - 50px); max-height: 250px; overflow-y: auto; background-color: #fff; border: 1px solid #ced4da; border-top: none; border-bottom-left-radius: 0.25rem; border-bottom-right-radius: 0.25rem; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 101; display: none; transition: border-color 0.3s, background-color 0.3s, color 0.3s; }
        .search-results.dark-mode { background-color: #495057; border-color: #5a6268; }
        .search-result-item { padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #eee; transition: background-color 0.2s, color 0.3s; }
        .search-result-item:last-child { border-bottom: none; }
        .search-result-item:hover { background-color: #f0f0f0; }
        .search-result-item.dark-mode:hover { background-color: #5a6268; }
        .search-result-item.dark-mode { color: #fff; }
        textarea { width: 100%; height: 150px; padding: 12px 15px; border: 1px solid #ced4da; border-radius: 0.25rem; font-family: 'Roboto', monospace; font-size: 0.9rem; resize: vertical; margin-bottom: 20px; transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, color 0.3s; background-color: #fff; color: #495057; }
        textarea:focus { border-color: #80bdff; box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); outline: 0; }
        textarea.dark-mode { background-color: #495057; color: #fff; border-color: #5a6268; }
        button { background-color: #007bff; color: white; padding: 12px 20px; border: none; cursor: pointer; border-radius: 0.25rem; font-size: 1rem; transition: background-color 0.3s, transform 0.2s; margin-bottom: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .sidebar button:last-child { margin-right: 0; }
        button:hover { background-color: #0056b3; transform: translateY(-1px); box-shadow: 0 3px 6px rgba(0,0,0,0.15); }
        button:active { transform: translateY(0); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        button.dark-mode { background-color: #6c757d; }
        button.dark-mode:hover { background-color: #5a6268; }
        #network { flex-grow: 1; height: 100vh; position: relative; z-index: 1; }
        .dark-mode-switch { display: flex; align-items: center; margin-bottom: 10px; }
        .dark-mode-switch label { margin-left: 10px; font-size: 1rem; color: #6c757d; transition: color 0.3s; }
        .dark-mode-switch label.dark-mode { color: #adb5bd; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #007bff; }
        input:focus + .slider { box-shadow: 0 0 1px #007bff; }
        input:checked + .slider:before { transform: translateX(22px); }
        .vis-network canvas { outline: none; }
        .vis-node.vis-box { border-radius: 0.5rem; border-width: 2px; padding: 8px 15px; font-size: 1rem; color: #495057; background: linear-gradient(145deg, #e2e8ec, #ffffff); box-shadow: 3px 3px 6px #bababa, -3px -3px 6px #ffffff; transition: color 0.3s, background 0.3s, box-shadow 0.3s, border-color 0.3s; }
        .vis-node.vis-box.dark-mode { color: #f8f9fa; background: linear-gradient(145deg, #373e45, #495057); box-shadow: 3px 3px 6px #272b2e, -3px -3px 6px #515960; border-color: #5a6268 !important; }
        .vis-node.vis-box.vis-hover { box-shadow: 5px 5px 10px #bababa, -5px -5px 10px #ffffff; }
        .vis-node.vis-box.dark-mode.vis-hover { box-shadow: 5px 5px 10px #272b2e, -5px -5px 10px #515960; }
        .vis-edge { color: #6c757d; transition: color 0.3s; }
        .vis-edge.dark-mode { color: #adb5bd; }
        .vis-edge.vis-hover { color: #495057; }
        .vis-edge.dark-mode.vis-hover { color: #fff; }
    </style>
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css"
            rel="stylesheet" type="text/css" />
        <link
            href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&family=Roboto+Mono&display=swap"
            rel="stylesheet">
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.min.js"></script>
    </head>
    <body class="dark-mode">
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>Family Tree Input</h2>
                <button class="sidebar-toggle">></button>
            </div>
            <div class="search-container">
                <input type="text" id="searchInput"
                    class="search-input dark-mode"
                    placeholder="Search Person...">
                <div id="searchResults" class="search-results dark-mode"></div>
            </div>
            <textarea id="input"
                placeholder="Enter family data here..."></textarea><br>
            <button onclick="generateTree()">Generate</button>
            <button onclick="clearAll()">Clear</button>
            <button id="fitViewButton" onclick="fitView()">Fit View</button>

            <div class="dark-mode-switch">
                <label class="switch">
                    <input type="checkbox" id="darkModeToggle" checked>
                    <span class="slider"></span>
                </label>
                <label for="darkModeToggle"
                    class="dark-mode-switch-label dark-mode">Dark Mode</label>
            </div>
        </div>

        <div id="network"></div>

        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <script>
        let network = null;
        let isDarkMode = true;
        let fuse = null;
        let peopleData = new Map();

        const sidebar = document.querySelector('.sidebar');
        const sidebarToggle = document.querySelector('.sidebar-toggle');
        let isSidebarCollapsed = false;  // Keep track of sidebar state.

        sidebarToggle.addEventListener('click', () => {
            isSidebarCollapsed = !isSidebarCollapsed;
            sidebar.classList.toggle('collapsed', isSidebarCollapsed);
        });

        const darkModeToggle = document.getElementById('darkModeToggle');
        const body = document.body;
        const textarea = document.getElementById('input');
        const buttons = document.querySelectorAll('button');
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const darkModeSwitchLabel = document.querySelector('.dark-mode-switch-label');

        function applyDarkModeToElements() {
            body.classList.toggle('dark-mode', isDarkMode);
            sidebar.classList.toggle('dark-mode', isDarkMode);
            textarea.classList.toggle('dark-mode', isDarkMode);
            buttons.forEach(button => button.classList.toggle('dark-mode', isDarkMode));
            sidebarToggle.classList.toggle('dark-mode', isDarkMode);
            searchInput.classList.toggle('dark-mode', isDarkMode);
            searchResults.classList.toggle('dark-mode', isDarkMode);
            darkModeSwitchLabel.classList.toggle('dark-mode', isDarkMode);
            document.querySelectorAll('.search-result-item').forEach(item => item.classList.toggle('dark-mode', isDarkMode));
        }

        darkModeToggle.addEventListener('change', () => {
            isDarkMode = darkModeToggle.checked;
            applyDarkModeToElements();
        });

        window.addEventListener('load', () => {
          applyDarkModeToElements();
        });

        function clearAll() {
            textarea.value = '';
            if (network) network.destroy();
            peopleData.clear();
            fuse = null;
            searchInput.value = '';
            searchResults.innerHTML = '';
            searchResults.style.display = 'none';
        }

        function fitView() {
            if (network) network.fit();
        }

        function generateTree() {
            const input = textarea.value.trim();
            peopleData.clear();
            const spouseRelations = new Set();
            const mothers = new Set();

            input.split('\n').forEach(line => {
                line = line.trim();
                if (!line) return;

                const [left = '', right = ''] = line.split('+').map(s => s.trim()); //Destructure with defaults
                if (left && right) {  // Check for valid spouses
                    processSpouses(peopleData, spouseRelations, left, right, mothers);
                } else {
                    processChild(peopleData, line);
                }
            });

            // Ensure children are added to both spouses
            peopleData.forEach(person => {
                person.children.forEach(child => {
                    person.spouses.forEach(spouse => {
                        const spouseNode = peopleData.get(spouse);
                        if (spouseNode && !spouseNode.children.includes(child)) {
                            spouseNode.children.push(child);
                        }
                    });
                });
            });

            const { nodes, edges } = createFamilyTrees(peopleData, mothers);
            drawNetwork(nodes, edges, mothers);

            const peopleList = Array.from(peopleData.values()).map(p => ({ name: p.name, displayName: p.displayName }));
            fuse = new Fuse(peopleList, {
                keys: ['name'],
                threshold: 0.4,
                includeScore: true,
                shouldSort: true,
            });
            setupSearch(); // Call setupSearch after fuse is initialized
        }

       function processSpouses(people, spouseRelations, left, right, mothers) {
            addPersonWithAncestry(people, left);
            addPersonWithAncestry(people, right);

            const key = [left, right].sort().join('+');
            if (!spouseRelations.has(key)) {
                people.get(left).spouses.add(right);
                people.get(right).spouses.add(left);
                spouseRelations.add(key);
                mothers.add(right);  //right side is mother.
            }
        }

        function processChild(people, child) {
            addPersonWithAncestry(people, child);
            const parent = findExistingParent(people, child);
            if (parent) linkParentChild(people, parent, child);
        }

        function addPersonWithAncestry(people, name) {
            if (!people.has(name)) {
                const displayName = name.split(' ').slice(0, 2).join(' ');
                people.set(name, createPerson(name, displayName));
                buildAncestryChain(people, name);
            }
        }

        function buildAncestryChain(people, name) {
            let current = name;
            while (true) {
                const parentName = extractParentName(current);
                if (!parentName) break;

                if (!people.has(parentName)) {
                    const parentDisplayName = parentName.split(' ').slice(0, 2).join(' ');
                    people.set(parentName, createPerson(parentName, parentDisplayName));
                }
                linkParentChild(people, parentName, current);
                current = parentName;
            }
        }

        function createPerson(name, displayName) {
            return { name, displayName, parent: null, spouses: new Set(), children: [], processed: false };
        }

        function linkParentChild(people, parent, child) {
            if (!people.get(parent).children.includes(child)) {
                people.get(parent).children.push(child);
            }
            people.get(child).parent = parent;
        }

        function extractParentName(name) {
            return name.split(' ').slice(1).join(' ') || null;
        }

        function findExistingParent(people, child) {
            let current = child;
            while (current) {
                const parent = people.get(current)?.parent;
                if (parent && people.has(parent)) return parent;
                current = parent;
            }
            return null;
        }

        function getFamilyRoots(people) {
            const surnames = new Set();
            for (const person of people.values()) { // Iterate directly over values
                if (!person.parent) {
                    surnames.add(getSurname(person.name));
                }
            }
            return Array.from(surnames);
        }

        function getSurname(name) {
            return name.split(' ').pop();
        }

        function createFamilyTrees(people, mothers) {
            const nodes = [];
            const edges = [];
            const processedPairs = new Set();
            const surnames = getFamilyRoots(people);

            surnames.forEach(surname => {
                const roots = Array.from(people.values())
                    .filter(p => !p.parent && getSurname(p.name) === surname)
                    .sort((a, b) => a.name.localeCompare(b.name));

                roots.forEach(root => {
                    const treeNodes = new Map();
                    const queue = [{ name: root.name, displayName: root.displayName, level: 0, tree: surname }];

                    while (queue.length > 0) {
                        const current = queue.shift();
                        const person = people.get(current.name);
                        const nodeId = `${current.name}@${current.tree}`;

                        if (!treeNodes.has(nodeId)) {
                            const nodeColorOptions = getNodeColorOptions(current.tree, isDarkMode);

                            nodes.push({
                                id: nodeId,
                                label: current.displayName,
                                level: current.level,
                                group: current.tree,
                                shape: 'box',
                                margin: 10,
                                font: { size: 14 },
                                ...nodeColorOptions
                            });
                            treeNodes.set(nodeId, true);
                        }

                        // Spouse handling. Use Array.from to handle Set properly.
                        Array.from(person.spouses).forEach(spouse => { //Use Array.from
                            const spouseNodeId = `${spouse}@${current.tree}`;
                            const edgePair = [nodeId, spouseNodeId].sort().join('+');

                            if (!processedPairs.has(edgePair)) {
                                edges.push({ from: nodeId, to: spouseNodeId, color: '#FF0000', dashes: true, width: 2 });
                                processedPairs.add(edgePair);

                                const spousePerson = people.get(spouse);
                                if(spousePerson) { //check spousePerson before adding to queue
                                    queue.unshift({ name: spouse, displayName: spousePerson.displayName, level: current.level, tree: current.tree });
                                }

                            }
                        });

                        // Child handling
                        person.children.forEach(child => {
                            const childNodeId = `${child}@${current.tree}`;
                            const edgeId = `${nodeId}->${childNodeId}`;

                            if (!processedPairs.has(edgeId)) {
                                edges.push({ from: nodeId, to: childNodeId, arrows: 'to', color: '#6c757d', motherEdge: mothers.has(current.name) });
                                processedPairs.add(edgeId);

                                const childPerson = people.get(child);
                                 if (childPerson) { // check childPerson exists.
                                    queue.push({ name: child, displayName: childPerson.displayName, level: current.level + 1, tree: current.tree });
                                }
                            }
                        });
                    }
                });
            });

            return { nodes, edges };
        }

        function drawNetwork(nodes, edges, mothers) {
            const container = document.getElementById('network');
            if (network) network.destroy();

            const filteredEdges = edges.filter(edge => {
                const fromName = edge.from.split('@')[0];
                return !(edge.motherEdge && mothers.has(fromName));
            });

            const data = { nodes, edges: filteredEdges };

            const options = {
                layout: { hierarchical: { enabled: true, direction: 'UD', sortMethod: 'directed', levelSeparation: 180, nodeSpacing: 150, treeSpacing: 250 } },
                edges: { smooth: { type: 'cubicBezier', forceDirection: 'vertical', roundness: 0.4 }, arrows: { to: { scaleFactor: 0.8 } }, width: 1.5 },
                physics: { hierarchicalRepulsion: { nodeDistance: 120 }, solver: 'hierarchicalRepulsion' },
                interaction: { dragNodes: true, dragView: true, zoomView: true, hover: true }
            };

            network = new vis.Network(container, data, options);


        }

        function getNodeColorOptions(group, isDarkMode) {
            const baseColor = stringToColor(group);
            const desaturatedColor = desaturateColor(baseColor, 60);

            const lightModeOptions = {
                color: { background: desaturatedColor, border: darkenColor(desaturatedColor, 20), highlight: { background: '#FFFFE0', border: '#000000' } },
                className: 'vis-box'
            };

            const darkModeOptions = {
                color: { background: darkenColor(desaturatedColor, 50), border: darkenColor(desaturatedColor, 70), highlight: { background: '#FFFFE0', border: '#ffffff' } },
                className: 'vis-box dark-mode'
            };

            return isDarkMode ? darkModeOptions : lightModeOptions;
        }

        function setupSearch() {
            function handleSearch() {
                const query = searchInput.value.trim(); // Get trimmed value.
                searchResults.innerHTML = '';  // Clear previous results.
                searchResults.style.display = query ? 'block' : 'none'; // Show/hide based on query.

                if (query && fuse) {
                    const results = fuse.search(query);
                    displaySearchResults(results);
                }
            }

            searchInput.addEventListener('input', handleSearch);
            searchInput.addEventListener('focus', handleSearch);  // Also search on focus.


            document.addEventListener('click', (event) => {
                if (!searchInput.contains(event.target) && !searchResults.contains(event.target)) {
                    searchResults.style.display = 'none';
                }
            });
        }

        function displaySearchResults(results) {
            searchResults.innerHTML = ''; // Clear previous results

            results.slice(0, 10).forEach(result => {
                const item = document.createElement('div');
                item.classList.add('search-result-item');
                if (isDarkMode) item.classList.add('dark-mode');  // Add dark-mode class
                item.innerHTML = highlightMatch(result.item.name, searchInput.value);

                item.addEventListener('click', () => {
                  if (network) {
                      const nodeId = findNodeIdByName(result.item.name);
                      if (nodeId) {
                          network.focus(nodeId, { scale: 1.5, animation: { duration: 500, easingFunction: 'easeInOutQuad' } });
                          highlightNodeAndConnections(nodeId);
                      }
                  }
                  searchResults.style.display = 'none'; // Hide results after click.
                });
                searchResults.appendChild(item);
            });
        }

        function findNodeIdByName(fullName) {
            if (!network) return null; // Early exit if network not initialized.
            return network.body.data.nodes.getIds().find(nodeId => nodeId.split('@')[0] === fullName) || null;
        }

        function highlightNodeAndConnections(nodeId) {
              if (!network) return;

              const connectedEdges = network.getConnectedEdges(nodeId);
              const connectedNodes = network.getConnectedNodes(nodeId);

              // Reset all nodes and edges to their default colors
              network.body.data.nodes.forEach(node => {
                if (node.savedColor) {
                  node.color = node.savedColor;
                  node.className = node.savedClassName;
                } else {
                  // If there's no saved color, it might not have been highlighted yet.
                  //  Apply the default color based on its group.  Important for first click
                  Object.assign(node, getNodeColorOptions(node.group, isDarkMode));

                }
                network.body.data.nodes.update(node); //Apply update
              });

              network.body.data.edges.forEach(edge => {
                edge.color = edge.savedColor || { color: isDarkMode? '#adb5bd' : '#6c757d'}; //Use saved color.
                edge.width = 1.5;
                network.body.data.edges.update(edge); //Apply update.
              });

              // Highlight the clicked node
              let clickedNode = network.body.data.nodes.get(nodeId);
              clickedNode.savedColor = clickedNode.color || {}; // Save the original color
              clickedNode.savedClassName = clickedNode.className;
              clickedNode.color = { background: '#FFFFE0', border: '#000000' };
              clickedNode.className = 'vis-box';
              network.body.data.nodes.update(clickedNode);


              // Highlight connected nodes
              connectedNodes.forEach(connectedNodeId => {
                if (connectedNodeId !== nodeId) {
                  let node = network.body.data.nodes.get(connectedNodeId);
                   if (!node.savedColor) {
                        node.savedColor = node.color || {};
                        node.savedClassName = node.className;
                    }
                  node.color = getNodeColorOptions(node.group, isDarkMode).color; //use getNodeColor
                  node.className = 'vis-box' + (isDarkMode ? ' dark-mode' : ''); //set classname correctly
                  network.body.data.nodes.update(node);
                }
              });

              // Highlight connected edges
              connectedEdges.forEach(edgeId => {
                let edge = network.body.data.edges.get(edgeId);
                edge.savedColor = edge.color || {}; // Save the original color
                edge.color = { color: '#000000' };
                edge.width = 3;
                network.body.data.edges.update(edge);
              });
        }

        function highlightMatch(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${escapeRegExp(query)})`, 'gi'); // Correctly escape the query
            return text.replace(regex, '<mark>$1</mark>');
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            const color = Math.floor(Math.abs((Math.sin(hash) * 16777215) % 16777215)).toString(16);
            return '#' + Array(6 - color.length + 1).join('0') + color;
        }

        function adjustColor(hexColor, percentage) {
            let color = hexColor.replace("#", "");
            const num = parseInt(color, 16);
            let amt = Math.round(2.55 * percentage);
            let R = (num >> 16) + amt;
            let G = (num >> 8 & 0x00FF) + amt;
            let B = (num & 0x0000FF) + amt;

            R = Math.max(0, Math.min(255, R));
            G = Math.max(0, Math.min(255, G));
            B = Math.max(0, Math.min(255, B));

            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function darkenColor(hexColor, percentage) {
            return adjustColor(hexColor, -percentage);
        }

        function desaturateColor(hexColor, percentage) {
            let color = hexColor.replace("#", "");
            let [h, s, l] = hexToHSL(color);

            s -= (percentage / 100);
            s = Math.max(0, Math.min(1, s));

            return hslToHex(h, s, l);
        }

        function hexToHSL(hex) {
            const num = parseInt(hex, 16);
            let r = (num >> 16) / 255;
            let g = (num >> 8 & 0x00FF) / 255;
            let b = (num & 0x0000FF) / 255;

            let max = Math.max(r, g, b);
            let min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h, s, l];
        }

        function hslToHex(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                let p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            const toHex = (x) => {
                const hex = Math.round(x * 255).toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            };

            return "#" + toHex(r) + toHex(g) + toHex(b);
        }
    </script>
    </body>
</html>