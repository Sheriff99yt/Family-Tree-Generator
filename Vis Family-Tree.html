<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Family Tree Generator</title>
    <style>
        :root {
            --primary: #6366f1;
            --primary-hover: #4f46e5;
            --secondary: #64748b;
            --secondary-hover: #475569;
            --background: #ffffff;
            --text: #1e293b;
            --border: #e2e8f0;
            --card-bg: #f8fafc;
            --node-bg: #f1f5f9;
        }

        .dark-mode {
            --primary: #818cf8;
            --primary-hover: #6366f1;
            --secondary: #94a3b8;
            --secondary-hover: #7c8ba1;
            --background: #0f172a;
            --text: #f8fafc;
            --border: #334155;
            --card-bg: #1e293b;
            --node-bg: #334155;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--background);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 80%;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            transform: translateX(-100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--card-bg);
            border-right: 1px solid var(--border);
            padding: 1rem;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
        }

        .sidebar-header h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text);
        }

        .mobile-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 60px;
            height: 50px;
            border-radius: 10px;
            background-color: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            z-index: 101;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .mobile-toggle.open {
            left: calc(80% + 20px);
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            flex-direction: column;
            margin-top: 1rem;
        }

        button {
            padding: 1rem;
            border-radius: 0.5rem;
            border: none;
            font-weight: 500;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            background-color: var(--primary);
            color: white;
            font-size: 1rem;
        }

        button.secondary {
            background-color: var(--secondary);
        }

        button:hover {
            filter: brightness(1.1);
        }

        button:active {
            filter: brightness(0.9);
        }

        .floating-controls {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            z-index: 100;
        }

        .dark-mode-toggle,
        .fit-view-toggle {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 1px solid var(--border);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }

        .dark-mode-toggle:hover,
        .fit-view-toggle:hover {
            transform: scale(1.1);
        }

        textarea {
            width: 100%;
            height: 230px;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            background: var(--background);
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            resize: vertical;
            font-size: 14px;
        }

        .input-container {
            position: relative;
            margin-top: 1rem;
        }

        .input-container .controls {
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .input-container .controls button {
            flex: 1;
            padding: 0.75rem;
        }

        .search-container {
            position: relative;
            margin-top: 1rem;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            background: var(--background);
            color: var(--text);
            font-size: 1rem;
        }

        .search-results {
            position: absolute;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: none;
            z-index: 101;
        }

        .search-result-item {
            padding: 1rem;
            cursor: pointer;
            color: var(--text);
            font-size: 1rem;
        }

        .search-result-item:hover {
            background: var(--primary);
            color: white;
        }

        #network {
            height: 100vh;
            background: var(--background);
            touch-action: pan-x pan-y;
        }

        @media (min-width: 768px) {
            .sidebar {
                width: 320px;
                height: 100vh;
                top: 0;
                bottom: auto;
                left: 0;
                transform: translateX(0);
                border-right: 1px solid var(--border);
                border-top: none;
                padding: 1.5rem;
                box-shadow: none;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .mobile-toggle {
                display: none;
            }

            #network {
                margin-left: 320px;
                height: 100vh;
            }

            .controls {
                flex-direction: row;
                gap: 0.75rem;
            }

            button {
                padding: 0.625rem 1.25rem;
            }

            .floating-controls {
                bottom: 1.5rem;
                right: 1.5rem;
            }
        }

        @media (max-width: 767px) {
            .floating-controls {
                bottom: 90px;
                right: 1rem;
            }
            
            .dark-mode-toggle,
            .fit-view-toggle {
                width: 42px;
                height: 42px;
                font-size: 1.2rem;
            }
        }
    </style>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
</head>
<body class="dark-mode">
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>Family Tree Generator</h2>
        </div>
        
        <div class="search-container">
            <input type="text" id="searchInput" class="search-input" placeholder="Search family members...">
            <div id="searchResults" class="search-results"></div>
        </div>
        
        <div class="input-container">
            <textarea id="input" placeholder="Enter family data here"></textarea>
            <div class="controls">
                <button onclick="generateTree()">Generate</button>
                <button class="secondary" onclick="clearAll()">Clear</button>
            </div>
        </div>
    </div>

    <button class="mobile-toggle" onclick="toggleSidebar()">â˜°</button>

    <div id="network"></div>

    <div class="floating-controls">
        <button id="layout-toggle" class="dark-mode-toggle" onclick="toggleLayout()" title="Toggle Layout">â‡•</button>
        <button class="fit-view-toggle" onclick="fitView()" title="Fit View">â¤¡</button>
        <button class="dark-mode-toggle" onclick="toggleDarkMode()" title="Toggle Dark Mode">ðŸŒ“</button>
    </div>

    <script>
        let peopleData = new Map();
        let isDarkMode = true;
        let network;
        let fuse;
        let layoutMode = 'vertical';

        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
            if (network) network.redraw();
        }

        function clearAll() {
            document.getElementById('input').value = '';
            if (network) network.destroy();
            peopleData.clear();
            fuse = null;
            document.getElementById('searchInput').value = '';
            document.getElementById('searchResults').innerHTML = '';
            document.getElementById('searchResults').style.display = 'none';
        }

        function fitView() {
            if (network) network.fit({
                animation: {
                    duration: 1000,
                    easingFunction: 'easeInOutQuad'
                }
            });
        }

        function generateTree() {
            const input = document.getElementById('input').value.trim();
            peopleData.clear();
            const spouseRelations = new Set();
            const mothers = new Set();

            input.split('\n').forEach(line => {
                line = line.trim();
                if (!line) return;

                if (line.includes('+')) {
                    const [left, right] = line.split('+').map(s => s.trim());
                    processSpouses(peopleData, spouseRelations, left, right, mothers);
                } else {
                    processChild(peopleData, line, mothers);
                }
            });

            peopleData.forEach(person => {
                person.children.forEach(child => {
                    person.spouses.forEach(spouse => {
                        const spouseNode = peopleData.get(spouse);
                        if (spouseNode && !spouseNode.children.includes(child)) {
                            spouseNode.children.push(child);
                        }
                    });
                });
            });

            const { nodes, edges } = createFamilyTrees(peopleData, mothers);
            drawNetwork(nodes, edges, mothers);

            const peopleList = Array.from(peopleData.values()).map(p => ({ name: p.name, displayName: p.displayName }));
            fuse = new Fuse(peopleList, {
                keys: ['name'],
                threshold: 0.4,
                includeScore: true,
                shouldSort: true,
            });
            setupSearch();
        }

        function processSpouses(people, spouseRelations, left, right, mothers) {
            addPersonWithAncestry(people, left);
            addPersonWithAncestry(people, right);

            const key = [left, right].sort().join('+');
            if (!spouseRelations.has(key)) {
                people.get(left).spouses.add(right);
                people.get(right).spouses.add(left);
                spouseRelations.add(key);
                mothers.add(right);
            }
        }

        function processChild(people, child, mothers) {
            addPersonWithAncestry(people, child);
            // Pass the mothers set to findExistingParent
            const potentialParent = findExistingParent(people, child, mothers);
            if (potentialParent) {
                linkParentChild(people, potentialParent, child);
            }
        }

        function addPersonWithAncestry(people, name) {
            if (!people.has(name)) {
                const displayName = name.split(' ').slice(0, 2).join(' ');
                people.set(name, createPerson(name, displayName));
                buildAncestryChain(people, name);
            }
        }

        function buildAncestryChain(people, name) {
            let current = name;
            while (true) {
                const parentName = extractParentName(current);
                if (!parentName) break;

                if (!people.has(parentName)) {
                    const parentDisplayName = parentName.split(' ').slice(0, 2).join(' ');
                    people.set(parentName, createPerson(parentName, parentDisplayName));
                }

                linkParentChild(people, parentName, current);
                current = parentName;
            }
        }

        function createPerson(name, displayName) {
            return {
                name: name,
                displayName: displayName,
                parents: [],
                spouses: new Set(),
                children: [],
                processed: false
            };
        }

        function linkParentChild(people, parent, child) {
            const childObj = people.get(child);
            if (!childObj.parents.includes(parent)) {
                childObj.parents.push(parent);
            }
            const parentObj = people.get(parent);
            if (!parentObj.children.includes(child)) {
                parentObj.children.push(child);
            }
        }

        function extractParentName(name) {
            return name.split(' ').slice(1).join(' ') || null;
        }

        // Update findExistingParent to receive mothers as a parameter.
        function findExistingParent(people, child, mothers) {
            const person = people.get(child);
            if (person.parents.length) {
                return person.parents.find(p => mothers.has(p)) || person.parents[0];
            }
            return null;
        }

        function createFamilyTrees(people, mothers) {
            const nodes = [];
            const edges = [];
            const processedPairs = new Set();
            const surnames = getFamilyRoots(people);

            surnames.forEach(surname => {
                const roots = Array.from(people.values())
                    .filter(p => p.parents.length === 0 && getSurname(p.name) === surname)
                    .sort((a, b) => a.name.localeCompare(b.name));

                roots.forEach(root => {
                    const treeNodes = new Map();
                    const queue = [{ name: root.name, displayName: root.displayName, level: 0, tree: surname }];

                    while (queue.length > 0) {
                        const current = queue.shift();
                        const person = people.get(current.name);
                        const nodeId = `${current.name}@${current.tree}`;

                        if (!treeNodes.has(nodeId)) {
                            const baseColor = stringToColor(current.tree);
                            const desaturatedColor = desaturateColor(baseColor, 70);
                            
                            nodes.push({
                                id: nodeId,
                                label: current.displayName,
                                level: current.level,
                                group: current.tree,
                                shape: 'box',
                                margin: 10,
                                font: { size: 14 },
                                color: {
                                    background: desaturatedColor,
                                    border: darkenColor(desaturatedColor, 20),
                                    highlight: {
                                        background: '#FFFF00',
                                        border: '#000000'
                                    }
                                }
                            });
                            treeNodes.set(nodeId, true);
                        }

                        Array.from(person.spouses).forEach(spouse => {
                            const spouseNodeId = `${spouse}@${current.tree}`;
                            const edgePair = [nodeId, spouseNodeId].sort().join('+');

                            if (!processedPairs.has(edgePair)) {
                                edges.push({
                                    from: nodeId,
                                    to: spouseNodeId,
                                    color: '#FF0000',
                                    dashes: true,
                                    width: 2
                                });
                                processedPairs.add(edgePair);

                                const spousePerson = people.get(spouse);
                                queue.unshift({
                                    name: spouse,
                                    displayName: spousePerson.displayName,
                                    level: current.level,
                                    tree: current.tree
                                });
                            }
                        });

                        person.children.forEach(child => {
                            const childNodeId = `${child}@${current.tree}`;
                            const edgeId = `${nodeId}->${childNodeId}`;

                            if (!processedPairs.has(edgeId)) {
                                edges.push({
                                    from: nodeId,
                                    to: childNodeId,
                                    arrows: 'to',
                                    color: '#2B7CE9',
                                    motherEdge: mothers.has(current.name)
                                });
                                processedPairs.add(edgeId);

                                const childPerson = people.get(child);
                                queue.push({
                                    name: child,
                                    displayName: childPerson.displayName,
                                    level: current.level + 1,
                                    tree: current.tree
                                });
                            }
                        });
                    }
                });
            });

            return { nodes, edges };
        }

        function drawNetwork(nodes, edges, mothers) {
            const container = document.getElementById('network');
            if (network) network.destroy();

            const data = {
                nodes: nodes,
                edges: edges
            };

            const options = {
                layout: {
                    hierarchical: {
                        enabled: true,
                        direction: 'UD',
                        sortMethod: 'directed',
                        levelSeparation: 200,
                        nodeSpacing: 200,
                        treeSpacing: 200
                    }
                },
                edges: {
                    smooth: {
                        type: "vertical"
                    },
                    arrows: { to: { scaleFactor: 1 } }
                },
                physics: true,
                interaction: {
                    dragNodes: true,
                    dragView: true,
                    zoomView: true
                }
            };

            network = new vis.Network(container, data, options);

            network.on("click", function (params) {
            });
        }

        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');

            searchInput.addEventListener('input', () => {
                const query = searchInput.value;
                if (!fuse || query.trim() === '') {
                    searchResults.innerHTML = '';
                    searchResults.style.display = 'none';
                    return;
                }
                const results = fuse.search(query);
                displaySearchResults(results);
                searchResults.style.display = 'block';
            });
            
            document.addEventListener('click', (event) => {
                const isClickInsideSearch = searchInput.contains(event.target);
                const isClickOnResultItem = searchResults.contains(event.target);
                if (!isClickInsideSearch && !isClickOnResultItem) {
                    searchResults.style.display = 'none';
                }
            });
            
            searchInput.addEventListener('focus', () => {
                if (searchInput.value.trim() !== '' && fuse) {
                    const results = fuse.search(searchInput.value);
                    displaySearchResults(results);
                    searchResults.style.display = 'block';
                }
            });
        }

        function displaySearchResults(results) {
            const searchResults = document.getElementById('searchResults');
            const searchInput = document.getElementById('searchInput');
            searchResults.innerHTML = '';
            results.slice(0, 10).forEach(result => {
                const item = document.createElement('div');
                item.classList.add('search-result-item');
                item.innerHTML = highlightMatch(result.item.name, searchInput.value);
                item.addEventListener('click', () => {
                    if (network) {
                        const nodeId = findNodeIdByName(result.item.name);
                        if (nodeId) {
                            network.focus(nodeId, {
                                scale: 1.5,
                                animation: {
                                    duration: 500,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                            network.selectNodes([nodeId]);
                        }
                    }
                    searchResults.innerHTML = '';
                    searchResults.style.display = 'none';
                });
                if (isDarkMode) {
                    item.classList.add('dark-mode');
                }
                searchResults.appendChild(item);
            });
        }

        function findNodeIdByName(fullName) {
            let correctNodeId = null;
            if (network) {
                network.body.data.nodes.getIds().forEach((nodeId) => {
                    const nodeFullName = nodeId.split('@')[0];
                    if (nodeFullName === fullName) {
                        correctNodeId = nodeId;
                    }
                });
            }
            return correctNodeId;
        }

        function highlightMatch(text, query) {
            if (!query) {
                return text;
            }
            const regex = new RegExp(`(${escapeRegExp(query)})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function getFamilyRoots(people) {
            const surnames = new Set();
            for (const [name, person] of people) {
                if (!person.parent) {
                    surnames.add(getSurname(name));
                }
            }
            return Array.from(surnames);
        }

        function getSurname(name) {
            return name.split(' ').pop();
        }

        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            const color = Math.floor(Math.abs(
                (Math.sin(hash) * 16777215) % 16777215
            )).toString(16);
            return '#' + Array(6 - color.length + 1).join('0') + color;
        }

        function adjustColor(hexColor, percentage) {
            let color = hexColor.replace("#", "");
            const num = parseInt(color, 16);
            let amt = Math.round(2.55 * percentage);
            let R = (num >> 16) + amt;
            let G = (num >> 8 & 0x00FF) + amt;
            let B = (num & 0x0000FF) + amt;

            R = Math.max(0, Math.min(255, R));
            G = Math.max(0, Math.min(255, G));
            B = Math.max(0, Math.min(255, B));

            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function darkenColor(hexColor, percentage) {
            return adjustColor(hexColor, -percentage);
        }

        function desaturateColor(hexColor, percentage) {
            let color = hexColor.replace("#", "");
            let [h, s, l] = hexToHSL(color);

            s -= (percentage / 100);
            s = Math.max(0, Math.min(1, s));

            return hslToHex(h, s, l);
        }

        function hexToHSL(hex) {
            const num = parseInt(hex, 16);
            let r = (num >> 16) / 255;
            let g = (num >> 8 & 0x00FF) / 255;
            let b = (num & 0x0000FF) / 255;

            let max = Math.max(r, g, b);
            let min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h, s, l];
        }

        function hslToHex(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                let p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            const toHex = (x) => {
                const hex = Math.round(x * 255).toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            };

            return "#" + toHex(r) + toHex(g) + toHex(b);
        }

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const mobileToggle = document.querySelector('.mobile-toggle');
            
            sidebar.classList.toggle('open');
            mobileToggle.classList.toggle('open');
        }

        let touchStartX = 0;
        const swipeThreshold = 50;

        document.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
        });

        document.addEventListener('touchend', e => {
            const touchEndX = e.changedTouches[0].clientX;
            const deltaX = touchEndX - touchStartX;
            
            if (Math.abs(deltaX) > swipeThreshold && window.innerWidth < 768) {
                if (deltaX < 0) {
                    document.querySelector('.sidebar').classList.remove('open');
                    document.querySelector('.mobile-toggle').classList.remove('open');
                }
            }
        });

        function toggleLayout() {
            layoutMode = layoutMode === 'vertical' ? 'horizontal' : 'vertical';
            if (network) {
                const direction = layoutMode === 'vertical' ? 'UD' : 'LR';
                const edgeType = layoutMode === 'vertical' ? 'vertical' : 'horizontal';
                network.setOptions({
                    layout: {
                        hierarchical: {
                            direction: direction
                        }
                    },
                    edges: {
                        smooth: {
                            type: edgeType
                        }
                    }
                });
            }
        }
    </script>
</body>
</html>
